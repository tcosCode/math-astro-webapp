---
export interface Props {
  videoId: string;
}

const { videoId } = Astro.props;
const playerContainerId = `Youtuber-container-${videoId}`;
---

<div id={playerContainerId} class="youtube-iframe-container"></div>

<style>
  .youtube-iframe-container {
    position: relative;
    padding-bottom: 56.25%; /* 16:9 aspect ratio */
    height: 0;
    overflow: hidden;
    max-width: 100%;
  }
  .youtube-iframe-container iframe {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: 0;
  }
</style>

<script define:vars={{ videoId, playerContainerId }}>
  // Variables globales para este player especÃ­fico
  const playerGlobalObjectName = `youtubePlayer_${playerContainerId}`;
  let ytPlayerInstance = null;
  let isPlayerReady = false;
  let initializationPromise = null;

  console.log("=== INIT PLAYER SCRIPT ===");
  console.log("Player ID:", playerGlobalObjectName);
  console.log("Container ID:", playerContainerId);

  // FunciÃ³n para verificar si el API estÃ¡ disponible
  function isYouTubeAPIReady() {
    return (
      window.YT && window.YT.Player && typeof window.YT.Player === "function"
    );
  }

  // FunciÃ³n para cargar el API de YouTube
  function loadYouTubeAPI() {
    return new Promise((resolve) => {
      if (isYouTubeAPIReady()) {
        resolve();
        return;
      }

      // Si ya hay un script cargÃ¡ndose, esperar
      if (window.YT) {
        const checkReady = () => {
          if (isYouTubeAPIReady()) {
            resolve();
          } else {
            setTimeout(checkReady, 100);
          }
        };
        checkReady();
        return;
      }

      // Cargar script del API
      const tag = document.createElement("script");
      tag.src = "https://www.youtube.com/iframe_api";

      window.onYouTubeIframeAPIReady = function () {
        resolve();
      };

      const firstScriptTag = document.getElementsByTagName("script")[0];
      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
    });
  }

  // FunciÃ³n MEJORADA: verificar si el contenedor existe Y el player estÃ¡ funcional
  function isPlayerValid() {
    // 1. Verificar que el contenedor existe en el DOM
    const container = document.getElementById(playerContainerId);
    if (!container) {
      console.log("âŒ Container not found in DOM");
      return false;
    }

    // 2. Verificar que tenemos una instancia del player
    if (!ytPlayerInstance) {
      console.log("âŒ No ytPlayerInstance");
      return false;
    }

    // 3. Verificar que el player estÃ¡ marcado como listo
    if (!isPlayerReady) {
      console.log("âŒ Player not ready");
      return false;
    }

    // 4. NO verificar iframe inmediatamente - puede no existir aÃºn durante la inicializaciÃ³n
    // En su lugar, verificar solo si el player puede responder a llamadas API
    try {
      const state = ytPlayerInstance.getPlayerState();
      // Estados vÃ¡lidos: -1 (unstarted), 0 (ended), 1 (playing), 2 (paused), 3 (buffering), 5 (cued)
      if (state >= -1 && state <= 5) {
        console.log("âœ… Player is valid, state:", state);
        return true;
      } else {
        console.log("âŒ Invalid player state:", state);
        return false;
      }
    } catch (error) {
      console.log("âŒ Player API call failed:", error.message);
      return false;
    }
  }

  // FunciÃ³n para limpiar completamente el estado
  function resetPlayerState() {
    console.log("ðŸ§¹ Resetting player state...");

    // Destruir el player existente de forma segura
    if (ytPlayerInstance && typeof ytPlayerInstance.destroy === "function") {
      try {
        ytPlayerInstance.destroy();
        console.log("âœ… Player destroyed successfully");
      } catch (error) {
        console.warn("âš ï¸ Error destroying player:", error);
      }
    }

    // Limpiar variables locales
    ytPlayerInstance = null;
    isPlayerReady = false;
    initializationPromise = null;

    // Limpiar el contenedor DOM
    const container = document.getElementById(playerContainerId);
    if (container) {
      container.innerHTML = "";
    }
  }

  // FunciÃ³n de seek con validaciÃ³n completa y mejor manejo de errores
  function performSeek(seconds) {
    console.log("=== PERFORM SEEK ===");
    console.log("Seconds:", seconds);

    // Verificar si el player es vÃ¡lido
    if (!isPlayerValid()) {
      console.warn("âš ï¸ Player invalid, attempting to recreate...");

      // Resetear y recrear
      resetPlayerState();

      // Crear nuevo player y luego hacer seek
      ensurePlayerReady()
        .then(() => {
          if (isPlayerValid()) {
            console.log("ðŸ”„ Player recreated, retrying seek...");
            // Dar mÃ¡s tiempo para que el player se estabilice
            setTimeout(() => performSeek(seconds), 1500);
          } else {
            console.error("âŒ Failed to recreate player");
          }
        })
        .catch((error) => {
          console.error("âŒ Error recreating player:", error);
        });

      return false;
    }

    try {
      console.log("âœ… Executing seekTo...");
      ytPlayerInstance.seekTo(seconds, true);

      // Opcional: reproducir despuÃ©s del seek con verificaciÃ³n adicional
      setTimeout(() => {
        if (
          isPlayerValid() &&
          typeof ytPlayerInstance.playVideo === "function"
        ) {
          try {
            ytPlayerInstance.playVideo();
          } catch (error) {
            console.warn("âš ï¸ Could not auto-play after seek:", error);
          }
        }
      }, 500);

      console.log("âœ… Seek completed successfully");
      return true;
    } catch (error) {
      console.error("âŒ Error during seek:", error);
      return false;
    }
  }

  // Callback cuando el player estÃ¡ listo
  function onPlayerReady(event) {
    console.log("=== PLAYER READY ===");
    console.log("Event:", event);

    ytPlayerInstance = event.target;
    isPlayerReady = true;

    // Actualizar el objeto global
    updateGlobalObject();

    console.log("âœ… Player registered globally as:", playerGlobalObjectName);

    // Test del player con delay adicional para asegurar estabilidad
    setTimeout(() => {
      if (isPlayerValid()) {
        console.log("=== PLAYER TEST ===");
        try {
          console.log("Player state:", ytPlayerInstance.getPlayerState());
          console.log("Video duration:", ytPlayerInstance.getDuration());
        } catch (e) {
          console.warn("Player test failed:", e);
        }
      }
    }, 1500); // Aumentado el delay
  }

  // FunciÃ³n para actualizar el objeto global
  function updateGlobalObject() {
    window[playerGlobalObjectName] = {
      seekTo: performSeek,
      player: ytPlayerInstance,
      isReady: isPlayerReady,
      videoId: videoId,
      containerId: playerContainerId,
      validate: isPlayerValid,
      recreate: () => {
        resetPlayerState();
        return ensurePlayerReady();
      },
    };
  }

  // Callback para errores
  function onPlayerError(event) {
    console.error("âŒ YouTube Player Error:", event.data);
    isPlayerReady = false;
    updateGlobalObject();
  }

  // Callback para cambios de estado
  function onPlayerStateChange(event) {
    console.log("ðŸ”„ Player state changed:", event.data);
    // Actualizar el objeto global cuando cambie el estado
    updateGlobalObject();
  }

  // FunciÃ³n principal para crear el player
  async function createYouTubePlayer() {
    console.log("=== CREATING PLAYER ===");

    try {
      // Verificar contenedor
      const container = document.getElementById(playerContainerId);
      if (!container) {
        console.error("âŒ Container not found:", playerContainerId);
        throw new Error("Container not found");
      }

      // Resetear estado previo
      resetPlayerState();

      // Cargar API
      await loadYouTubeAPI();
      console.log("âœ… YouTube API loaded");

      // PequeÃ±o delay para asegurar que el DOM estÃ© estable
      await new Promise((resolve) => setTimeout(resolve, 100));

      // Verificar que el contenedor sigue existiendo
      const freshContainer = document.getElementById(playerContainerId);
      if (!freshContainer) {
        console.error("âŒ Container disappeared after API load");
        throw new Error("Container disappeared");
      }

      // Crear player
      console.log("Creating YT.Player...");

      // Retornar una promesa que se resuelve cuando el player estÃ© listo
      return new Promise((resolve, reject) => {
        try {
          const player = new YT.Player(playerContainerId, {
            height: "100%",
            width: "100%",
            videoId: videoId,
            playerVars: {
              playsinline: 1,
              enablejsapi: 1,
              origin: window.location.origin,
              widget_referrer: window.location.href,
            },
            events: {
              onReady: (event) => {
                onPlayerReady(event);
                // Dar tiempo adicional antes de resolver
                setTimeout(() => resolve(player), 500);
              },
              onError: (event) => {
                onPlayerError(event);
                reject(new Error(`Player error: ${event.data}`));
              },
              onStateChange: onPlayerStateChange,
            },
          });

          console.log("âœ… YT.Player created:", player);
        } catch (error) {
          console.error("âŒ Error creating YT.Player:", error);
          reject(error);
        }
      });
    } catch (error) {
      console.error("âŒ Error in createYouTubePlayer:", error);
      throw error;
    }
  }

  // FunciÃ³n para asegurar que el player estÃ© listo
  async function ensurePlayerReady() {
    // Si ya tenemos un player vÃ¡lido, no hacer nada
    if (isPlayerValid()) {
      console.log("âœ… Player already valid");
      return;
    }

    // Si ya hay una inicializaciÃ³n en progreso, esperar
    if (initializationPromise) {
      console.log("â³ Waiting for existing initialization...");
      try {
        await initializationPromise;
        return;
      } catch (error) {
        console.warn("Previous initialization failed:", error);
        initializationPromise = null;
      }
    }

    // Crear nueva inicializaciÃ³n
    console.log("ðŸš€ Starting player initialization...");
    initializationPromise = createYouTubePlayer();

    try {
      await initializationPromise;
      console.log("âœ… Player initialization completed");
    } catch (error) {
      console.error("âŒ Player initialization failed:", error);
      initializationPromise = null;
      throw error;
    }
  }

  // InicializaciÃ³n principal mejorada
  async function initPlayer() {
    console.log("=== INIT PLAYER ===");

    // Triple verificaciÃ³n del contenedor
    let container = document.getElementById(playerContainerId);
    if (!container) {
      console.log("Container not found, waiting...");
      await new Promise((resolve) => setTimeout(resolve, 100));
      container = document.getElementById(playerContainerId);

      if (!container) {
        console.error("âŒ Container still not found after wait");
        return;
      }
    }

    console.log("âœ… Container found, initializing player...");

    try {
      await ensurePlayerReady();
    } catch (error) {
      console.error("âŒ Failed to initialize player:", error);
    }
  }

  // Registrar objeto global inmediatamente con mejor manejo de inicializaciÃ³n
  window[playerGlobalObjectName] = {
    seekTo: function (seconds) {
      console.log("ðŸŽ¯ Seek requested:", seconds);

      if (isPlayerValid()) {
        return performSeek(seconds);
      }

      console.warn("âš ï¸ Player not ready, initializing...");

      // Esperar por el contenedor antes de inicializar
      waitForContainer()
        .then(() => {
          return ensurePlayerReady();
        })
        .then(() => {
          if (isPlayerValid()) {
            setTimeout(() => performSeek(seconds), 1000);
          } else {
            console.error("âŒ Failed to initialize player for seek");
          }
        })
        .catch((error) => {
          console.error("âŒ Error during player initialization:", error);
        });

      return false;
    },
    player: null,
    isReady: false,
    videoId: videoId,
    containerId: playerContainerId,
    validate: isPlayerValid,
    recreate: () => {
      resetPlayerState();
      return waitForContainer().then(() => ensurePlayerReady());
    },
  };

  // FunciÃ³n para verificar si el contenedor estÃ¡ listo en el DOM
  function waitForContainer() {
    return new Promise((resolve) => {
      const checkContainer = () => {
        const container = document.getElementById(playerContainerId);
        if (container) {
          resolve();
        } else {
          setTimeout(checkContainer, 100); // Aumenta el intervalo a 100ms
        }
      };
      checkContainer();
    });
  }

  // InicializaciÃ³n mejorada con espera por contenedor
  async function initPlayerWhenReady() {
    console.log("=== WAITING FOR CONTAINER ===");

    try {
      // Esperar a que el contenedor estÃ© disponible y visible
      await waitForContainer();
      console.log("âœ… Container is ready");

      // PequeÃ±o delay adicional para asegurar estabilidad
      await new Promise((resolve) => setTimeout(resolve, 200));

      // Ahora inicializar el player
      await initPlayer();
    } catch (error) {
      console.error("âŒ Error during initialization:", error);
    }
  }

  // Inicializar cuando el DOM estÃ© listo
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initPlayerWhenReady);
  } else {
    // Si el DOM ya estÃ¡ listo, inicializar con espera por contenedor
    initPlayerWhenReady();
  }

  // Para debugging
  window[`debug_${playerContainerId}`] = {
    getPlayer: () => ytPlayerInstance,
    getReady: () => isPlayerReady,
    testSeek: (seconds) => performSeek(seconds),
    getGlobal: () => window[playerGlobalObjectName],
    isValid: isPlayerValid,
    recreate: () => ensurePlayerReady(),
    reset: resetPlayerState,
    forceInit: initPlayer,
  };

  // Al final del script, despuÃ©s de la inicializaciÃ³n
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (!document.getElementById(playerContainerId)) {
        resetPlayerState();
        observer.disconnect();
      }
    });
  });

  observer.observe(document.body, { childList: true, subtree: true });

  console.log("âœ… Player script loaded for:", playerContainerId);

  // En el script del componente
  document.addEventListener("astro:page-load", () => {
    initPlayerWhenReady();
  });
</script>
