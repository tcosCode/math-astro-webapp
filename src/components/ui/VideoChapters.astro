---
import type { VideoChapter } from "@types";
import List from "@assets/icons/list.svg";

interface Props {
  chapters: VideoChapter[];
  videoId: string;
}

const { chapters, videoId } = Astro.props;
const playerGlobalObjectName = `youtubePlayer_Youtuber-container-${videoId}`;
---

{
  chapters.length > 0 && (
    <div class="video-chapters">
      <div class="title-chapters">
        <List class="svg-stroke video-chapters-icon" />
        <h3>Contenido del video</h3>
      </div>
      <ul>
        {chapters.map((chapter) => (
          <li class="time-chapter">
            <a
              href="#"
              data-time={chapter.time}
              class="chapter-link"
              onclick={`handleChapterClick(event, '${chapter.time}', '${playerGlobalObjectName}')`}
            >
              {chapter.time} - {chapter.title}
            </a>
          </li>
        ))}
      </ul>
    </div>
  )
}

<script is:inline>
  // Funci√≥n para parsear timestamp a segundos
  function parseTimestampToSeconds(timestamp) {
    const parts = timestamp.split(":").map(Number);
    let seconds = 0;
    if (parts.length === 3) {
      seconds = parts[0] * 3600 + parts[1] * 60 + parts[2];
    } else if (parts.length === 2) {
      seconds = parts[0] * 60 + parts[1];
    } else if (parts.length === 1) {
      seconds = parts[0];
    }
    return seconds;
  }

  // Funci√≥n principal mejorada para manejar clicks en cap√≠tulos
  function handleChapterClick(event, timeString, playerObjectName) {
    event.preventDefault();

    const seconds = parseTimestampToSeconds(timeString);

    console.log("=== CHAPTER CLICK DEBUG ===");
    console.log("Timestamp:", timeString, "->", seconds, "seconds");
    console.log("Looking for player:", playerObjectName);

    // Verificar si el objeto global existe
    if (!window[playerObjectName]) {
      console.error("‚ùå Player object not found:", playerObjectName);
      showUserMessage(
        "El reproductor no est√° disponible. Recargando la p√°gina...",
        "error",
      );
      // Recargar la p√°gina como √∫ltimo recurso
      setTimeout(() => window.location.reload(), 2000);
      return;
    }

    const playerObj = window[playerObjectName];
    console.log("Player object:", playerObj);

    // Usar la funci√≥n validate si est√° disponible
    const isPlayerValid = playerObj.validate
      ? playerObj.validate()
      : playerObj.isReady;
    console.log("Player valid:", isPlayerValid);

    if (isPlayerValid) {
      console.log("üéØ Player is valid, attempting seek...");
      const success = playerObj.seekTo(seconds);

      if (success) {
        showUserMessage(`Saltando a ${timeString}`, "success");
      } else {
        console.warn("‚ö†Ô∏è Seek returned false, will retry...");
        retrySeekWithFeedback(seconds, timeString, playerObj);
      }
    } else {
      console.warn("‚ö†Ô∏è Player not valid, attempting to recreate...");
      showUserMessage("Preparando reproductor...", "info");

      // Intentar recrear el player si tiene esa funci√≥n
      if (playerObj.recreate && typeof playerObj.recreate === "function") {
        playerObj
          .recreate()
          .then(() => {
            console.log("üîÑ Player recreated, attempting seek...");
            setTimeout(() => {
              const newSuccess = playerObj.seekTo(seconds);
              if (newSuccess) {
                showUserMessage(`Saltando a ${timeString}`, "success");
              } else {
                retrySeekWithFeedback(seconds, timeString, playerObj);
              }
            }, 1000);
          })
          .catch((error) => {
            console.error("‚ùå Failed to recreate player:", error);
            showUserMessage("Error al cargar el reproductor", "error");
          });
      } else {
        // Fallback: intentar seek directo
        retrySeekWithFeedback(seconds, timeString, playerObj);
      }
    }
  }

  // Funci√≥n para reintentar seek con feedback visual
  function retrySeekWithFeedback(seconds, timeString, playerObj) {
    let attempts = 0;
    const maxAttempts = 8;
    const baseDelay = 500;

    showUserMessage("Sincronizando reproductor...", "info");

    function attemptSeek() {
      attempts++;
      console.log(`üîÑ Retry attempt ${attempts}/${maxAttempts}`);

      // Verificar si el player ahora es v√°lido
      const isValid = playerObj.validate
        ? playerObj.validate()
        : playerObj.isReady;

      if (isValid) {
        console.log("‚úÖ Player ready on retry, attempting seek...");
        const success = playerObj.seekTo(seconds);

        if (success) {
          console.log("‚úÖ Seek successful on retry!");
          showUserMessage(`Saltando a ${timeString}`, "success");
          return;
        }
      }

      if (attempts >= maxAttempts) {
        console.error("‚ùå Max retry attempts reached");
        showUserMessage(
          "No se pudo sincronizar. Intenta recargar la p√°gina.",
          "error",
        );
        return;
      }

      // Retry with increasing delay
      const delay = baseDelay + attempts * 300;
      setTimeout(attemptSeek, delay);
    }

    // Start retrying after a short delay
    setTimeout(attemptSeek, 200);
  }

  // Funci√≥n para mostrar mensajes al usuario
  function showUserMessage(message, type = "info") {
    // Remover mensaje anterior si existe
    const existingMessage = document.querySelector(".chapter-message");
    if (existingMessage) {
      existingMessage.remove();
    }

    // Crear elemento del mensaje
    const messageEl = document.createElement("div");
    messageEl.className = `chapter-message chapter-message-${type}`;
    messageEl.textContent = message;

    // Estilos inline para el mensaje
    messageEl.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 12px 20px;
      border-radius: 8px;
      color: white;
      font-weight: 500;
      z-index: 10000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      font-size: 14px;
      max-width: 300px;
      transition: all 0.3s ease;
    `;

    // Colores seg√∫n el tipo
    switch (type) {
      case "success":
        messageEl.style.backgroundColor = "#10B981";
        break;
      case "error":
        messageEl.style.backgroundColor = "#EF4444";
        break;
      case "info":
      default:
        messageEl.style.backgroundColor = "#3B82F6";
        break;
    }

    // Agregar al DOM
    document.body.appendChild(messageEl);

    // Auto-remover despu√©s de un tiempo
    const duration = type === "error" ? 5000 : 3000;
    setTimeout(() => {
      messageEl.style.opacity = "0";
      messageEl.style.transform = "translateX(100%)";
      setTimeout(() => messageEl.remove(), 300);
    }, duration);
  }

  // Funci√≥n de debug mejorada
  window.debugChapterSystem = function () {
    console.log("=== CHAPTER SYSTEM DEBUG ===");

    // Encontrar todos los players
    const allPlayers = Object.keys(window).filter((key) =>
      key.startsWith("youtubePlayer"),
    );

    console.log("Available players:", allPlayers);

    allPlayers.forEach((playerName) => {
      const player = window[playerName];
      console.log(`\n${playerName}:`);
      console.log("  - Object:", player);
      console.log("  - isReady:", player?.isReady);
      console.log("  - seekTo type:", typeof player?.seekTo);
      console.log("  - videoId:", player?.videoId);
      console.log("  - containerId:", player?.containerId);

      // Test validation function if available
      if (player?.validate && typeof player.validate === "function") {
        console.log("  - validate():", player.validate());
      }

      // Test the player if ready
      if (player?.validate ? player.validate() : player?.isReady) {
        console.log("  - Testing seek to 10 seconds...");
        const result = player.seekTo(10);
        console.log("  - Test result:", result);
      }
    });

    return allPlayers;
  };

  // Funci√≥n para forzar recreaci√≥n de todos los players
  window.recreateAllPlayers = function () {
    const allPlayers = Object.keys(window).filter((key) =>
      key.startsWith("youtubePlayer"),
    );

    console.log("üîÑ Recreating all players:", allPlayers);

    allPlayers.forEach((playerName) => {
      const player = window[playerName];
      if (player?.recreate && typeof player.recreate === "function") {
        console.log(`üîÑ Recreating ${playerName}...`);
        player
          .recreate()
          .catch((e) => console.error(`Failed to recreate ${playerName}:`, e));
      }
    });
  };

  // Auto-debug cuando se cargan los cap√≠tulos
  document.addEventListener("DOMContentLoaded", function () {
    setTimeout(() => {
      console.log("=== AUTO-DEBUG: VideoChapters loaded ===");
      debugChapterSystem();
    }, 2000);
  });

  // Debug adicional para detectar problemas de navegaci√≥n
  let pageLoadTime = Date.now();
  window.addEventListener("load", () => {
    pageLoadTime = Date.now();
    console.log("üîç Page fully loaded at:", pageLoadTime);
  });

  // Debug cuando se hace click en un cap√≠tulo
  document.addEventListener("click", (e) => {
    if (e.target.classList.contains("chapter-link")) {
      const timeSinceLoad = Date.now() - pageLoadTime;
      console.log("üîç Chapter clicked", timeSinceLoad, "ms after page load");
    }
  });
</script>

<style>
  .video-chapters {
    border-radius: 0.75rem;
    background-color: hsl(0 0% 100%);
    border: 1px solid var(--light-grey-2);
    overflow: hidden;
    box-shadow: 0 2px 2px rgba(0, 0, 0, 0.1);
  }

  .title-chapters {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 1rem;
    border: 1px solid var(--light-grey-2);
  }

  .video-data-icon {
    margin-right: 0.25rem;
    width: 16px;
  }

  .chapter-link {
    display: flex;
    padding: 1rem;
    cursor: pointer;
    border-bottom: 1px solid var(--light-grey-2);
    transition: all 0.3s ease;
    text-decoration: none;
    color: inherit;
  }

  .time-chapter:hover {
    background-color: var(--light-grey);
  }

  .chapter-link:hover {
    text-decoration: none;
  }

  /* Estilos para los mensajes de estado */
  .chapter-message {
    animation: slideIn 0.3s ease;
  }

  @keyframes slideIn {
    from {
      transform: translateX(100%);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }
</style>
